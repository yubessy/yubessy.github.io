<!-- $theme: gaia -->

# Type Erasure と Reflection のはなし

##### @yubessy

#### 0x64物語 Reboot #08

#### "静的型付き言語"

---

### 静的型付き言語 とは？

* 静的型付け機構を搭載した処理系で処理される言語
* 言語が静的型付きかは**構文ではなく処理系**による
* たとえば以下のようなことも可能
    * Javaプログラムを静的型付けなしで実行
    * Pythonプログラムに静的型付けを適用

---

#### 静的型付け とは？

* プログラムの実行前に変数や関数などの型を決めること
* プログラムの実行前 ≠ コンパイル時
    * 例: mypy = 型検査のみでコンパイルはしない
* とはいえ大抵はコンパイル時に型検査も行う

---

### 静的型付けの意義

* めんどくさい？
    * `Map<String, String> listA = new HashMap<String, String>()`
* むずかしい？
    * ジェネリクス, 代数的データ型, ...
* 本来のメリット
    * プログラムの実行前にエラーを発見
    * 「刀を抜く前に勝負がついている」

---

#### ※語りだすと長くなるので省略

---

### あれ？

###### もしかしてプログラムの実行時に型は要らない・・・？

---

### 実行時に型情報は必要？

* 実は必要ない場合も多い
* 型システムの健全性 (≠ 完全性)
    * 型検査が成功 ⇒ 実行時に型エラーが起こらない
* 健全性が保たれていれば実行時に型情報は必要ない
    * 「あたらなければどうということはない」
* いくつかの言語ではこの性質に基づいて**Type Erasure**を行う

---

### Type Erasure (型消去)

* コンパイル時にプログラムから型情報を取り除くこと
* 無駄なものを省くだけでなく言語機能の実現に使われることも
* Java, Scala
    * Type Erasureによりジェネリクスを実現
    * この方法ならJVMの後方互換性を保てる

---

### 例

```java
List<String> list = new ArrayList<String>();
list.add("Hi");
String x = list.get(0);
```

```java
List list = new ArrayList();
list.add("Hi");
String x = (String) list.get(0);
```

---

### Again: 実行時に型情報は必要？

* 実行時に型情報がほしい場合もある
* 人間のためのドキュメントやデバッグ
* データが与えられないと型が決まらない場合
    * JSONのパース
* -> Java, Scala では**Reflection**を用意

---

### Reflection (自己言及)

* プログラムが自身のメタデータを実行時に利用すること
* Reflectionを利用すると自己の型情報が得られる


型システムによって挿入される定数
「ここに渡される変数の型は覚えておいてね（あとで使うから）」

https://docs.scala-lang.org/ja/overviews/reflection/overview.html

---

### 例

* TBD (ScalaのTypeTag)

```scala
```

---

### 型推論と型消去

* 型消去は型推論と対になる概念
* 最近の言語における型の儚い一生
    1. 人間は型を書かない
    2. 型推論で型をつける
    3. 型検査で型エラーがないことを確認
    4. 型消去で型を消す
    5. リフレクションのために一部だけ生き残る

---

### イメージ

ピクミン
