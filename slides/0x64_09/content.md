# 実装 型推論

0x64物語 第09夜 "型"

Shotaro Tanaka

---

Disclaimer

* 社内勉強会用資料です
* 内容には責任を持ちません

---

～前回までのあらすじ～

---

OCamlでOCaml（のサブセット言語）のREPLを実装

```
TODO
```

---

静的な型システムはまだない

```
TODO
```

---

～本編～

---

1. OCamlでOCamlの対話型インタプリタ（REPL）を実装
2. **できたインタプリタに型推論機構を付与**

---

型推論

> 型推論（かたすいろん）とはプログラミング言語の機能の1つで、静的な型付けを持つ言語において、変数や関数の型を宣言しなくてもそれを導くのに使われた関数の型シグネチャなどから自動的に型を決定する機構のこと。
>
> from 型推論 - Wikipedia

---

プリミティブ演算の型推論

```
1;;
1: int

1 > 0;;
true: bool
```

---

構文木をたどればできる

```

```

---

関数定義の型推論

```
fun x -> x + 1
-: ?
```

---

人間の思考

1. `1` は `int`
2. `+` は `int -> int -> int` だから `x + 1` は `int`
  * ついでに `x` は `int`
3. だからこれは `int -> int`

---

コンピュータのきもち

* 誰が `x + 1` を先に見ろといった？？？
* それ `fun f -> fun g -> f g` の前でも言えんの？

---

ちゃんと（コンピュータにできるように）やる

---

定義

$$ e := x \mid n \mid b \mid e_1 \, \rm{op} \, e_2 \mid \rm{if} \, e_1 \, \rm{then} \, e_2 \, \rm{else} e_3 $$
$$ \qquad \mid \rm{fun} \, x \rightarrow e \mid e_1 \; e_2 $$

---

$$
式 e ::= x \| n \| b \| e_1 op e_2 \| if e_1 then e_2 else e_3

      \| fun x -> e \| e1 e2 \\
x: 変数 \\
n: 整数 \\
b: 真理値 \\
op: 2項演算子 \\
型 \gamma ::= \alpha \| int \| bool \| \gamma_1 \arrow \gamma_2 \\
\alpha: 型変数
$$

---

定義（つづき）

* **型環境** $\Gamma$ : 変数に対して仮定する型に関する情報を保持
  * 変数から型への部分関数とみなせる
  * $\Gamma(x) = int$ のとき x の型は int
* $e : \gamma$ 式 $e$ が型 $\gamma$ をもつという **型判断**
* 型付け規則


---

プリミティブ演算の型付け規則

$$
$$

* 型付け規則がそのまま型推論アルゴリズムとなる

---

関数定義の型付け規則

$$
$$

* そのままでは型推論に使えない

---

型推論アルゴリズム

* 型が未知の式に出くわしたら、とりあえず型変数を置いて推論を続ける
* 推論の過程で型変数の実際の型が徐々に明らかになる
* 推論が終わると、型変数とその実際の型の対応関係が得られている
  * この対応関係を **型代入** と呼ぶ

---

型代入

---

実はまだ話せてないこと：多相性

```
let f = fun x -> x in
  f true && f 1 > 0;;
```

* 同一式の中で `f: bool -> bool` と `f: int -> int` が共存できない

---

力尽きたので詳しく知りたい人はこちらをどうぞ

http://www.fos.kuis.kyoto-u.ac.jp/~t-sekiym/classes/isle4/
