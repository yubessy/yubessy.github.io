<!-- $theme: gaia -->

### 不動点コンビネータ？

##### @yubessy

#### 0x64物語 Reboot #12

#### "λ"

---

##### ※今日は珍しくJavaScript(ES6)でお送りします！

---

### Q1. 階乗を計算せよ

---

### A1

```js
for (var p = 1, n = 1; n <= 5; n++) p *= n;
p;
```

---

### Q2. ループを使わずに階乗を計算せよ

```js
var f = n => n == 0 ? 1 : n * f(n - 1);
f(5);
```

---

### A2

---

### Q3. ループと再帰を使わずに階乗を計算せよ

---

### A3

```js
(g => (x => g(y => x(x)(y)))(x => g(y => x(x)(y))))(f => n => n == 0 ? 1 : n * f(n - 1))(5)
```

---

### なぜこうなるのか

式を３つの部分に分けてみる

```js
Z = g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
g = f => n => n == 0 ? 1 : n * f(n - 1)
x = 5
```

`g` は階乗の定義とよく似ている

```js
f = n => n == 0 ? 1 : n * f(n - 1)
```

ただし名前の付いた関数ではなく **ラムダ式** である

---

### なぜこうなるのか

ここでもし `Z` が以下をみたすなら？

```js
Z(g) = g(Z(g))
```

```js
  Z(f => n => n == 0 ? 1 : n * f(n - 1))(5)
= (f => n => n == 0 ? 1 : n * f(n - 1))(Z(f => n => n == 0 ? 1 : n * f(n - 1)))(5)
= (n => n == 0 ? 1 : n * (Z(f => n => n == 0 ? 1 : n * f(n - 1)))(n - 1))(5)
= 5 == 0 ? 1 : 5 * (Z(f => n => n == 0 ? 1 : n * f(n - 1)))(5 - 1)
= 5 * (Z(f => n => n == 0 ? 1 : n * f(n - 1)))(4)
= ...
= 5 * 4 * 3 * 2 * 1
```

※２行目以降の `Z(...)` は厳密には先に評価される

---

### なぜこうなるのか

```js
Z = g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
```

は実際に `Z(g) = g(Z(g))` をみたす

```js
  Z(g)
= (g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y))))(g)
= (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
= (h => g(x => h(h)(x)))(h => g(y => h(h)(y)))
= g(x => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))(x))
= g((h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
= g(Z(g))
```

---

### 再掲

```js
(g => (x => g(y => x(x)(y)))(x => g(y => x(x)(y))))(f => n => n == 0 ? 1 : n * f(n - 1))(5)
```

このように無名関数のみで再帰に相当する計算を行うことを **無名再帰** という
また `fix(g) = g(fix(g))` をみたす高階関数 `fix` を **不動点コンビネータ** という
`Z` はよく知られた不動点コンビネータのひとつ
※遅延評価言語ではより簡単な形式にできる

---

### まとめ？

* ループも再帰も使わずに再帰っぽいことがしたい
* -> 不動点コンビネータを使う必要がある
* たぶん今日は5分以内

---

![](pop.jpg)

---

### まとまってない

* ループも再帰も使わずに再帰っぽいことがしたい
* -> ~~不動点コンビネータを使う必要がある~~
* 実は使わなくてもできる

---

### 不動点コンビネータを使わない例

```js
(g => g(g))(f => n => n == 0 ? 1 : n * f(f)(n - 1))(5)
```

`g => g(g)` は自己適用コンビネータと呼ばれる
不動点コンビネータではないが、こっちのほうがシンプル

---

### 真のまとめ

* 不動点コンビネータ以外の方法でも無名再帰はできる
* 自己適用コンビネータを使うとシンプル
  * ただし関数の body が若干変わる
* 不動点コンビネータを使ってももちろんできる
  * こちらは関数の body を変えなくてよい

---

### ちなみに

不動点コンビネータや自己適用コンビネータの
型について語りだすと10や20分ではすまない

本当はHaskellやOCamlでやりたかったけど
自己規制でJavaScriptにしました
