<!-- $theme: gaia -->

### 不動点コンビネータ

##### @yubessy

#### 0x64物語 Reboot #12

#### "λ"

---

##### ※今日は珍しくJavaScript(ES6)でお送りします！

---

### Q1. 階乗を計算せよ

---

### A1

```
for (var p = 1, n = 1; n <= 5; n++) p *= n;
p;
```

---

### Q2. ループを使わずに階乗を計算せよ

```
var f = n => n == 0 ? 1 : n * f(n - 1);
f(5);
```

---

### A2

---

### Q3. ループと再帰を使わずに階乗を計算せよ

---

### A3

```
(g => (x => g(y => x(x)(y)))(x => g(y => x(x)(y))))(f => n => n == 0 ? 1 : n * f(n - 1))(5)
```

---

### なぜこうなるのか

式を３つの部分に分けてみる

```
Z … g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
g … f => n => n == 0 ? 1 : n * f(n - 1)
x … 5
```

`g` は階乗の定義とよく似ている

```
var f = n => n == 0 ? 1 : n * f(n - 1);
```

ただし名前の付いた関数ではなく **ラムダ式** である

---

### なぜこうなるのか

ここでもし `Z` が以下をみたすなら？

```
Z(g) = g(Z(g))
```

```
  Z(f => n => n == 0 ? 1 : n * f(n - 1))(5)
= (f => n => n == 0 ? 1 : n * f(n - 1))(Z(f => n => n == 0 ? 1 : n * f(n - 1)))(5)
= (n => n == 0 ? 1 : n * (Z(f => n => n == 0 ? 1 : n * f(n - 1)))(n - 1))(5)
= 5 == 0 ? 1 : 5 * (Z(f => n => n == 0 ? 1 : n * f(n - 1)))(5 - 1)
= 5 * (Z(f => n => n == 0 ? 1 : n * f(n - 1)))(4)
= ...
= 5 * 4 * 3 * 2 * 1
```

※２行目以降の `Z(...)` は厳密には先に評価される

---

### なぜこうなるのか

```
Z … g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
```

は実際に `Z(g) = g(Z(g))` をみたす

```
  Z(g)
= (g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y))))(g)
= (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
= (h => g(x => h(h)(x)))(h => g(y => h(h)(y)))
= g(x => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))(x))
= g((h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
= g(Z(g))
```

---

### 再掲

```
(g => (x => g(y => x(x)(y)))(x => g(y => x(x)(y))))(f => n => n == 0 ? 1 : n * f(n - 1))(5)
```

このように無名関数のみで再帰に相当する計算を行うことを **無名再帰** という
また `fix(g) = g(fix(g))` をみたす高階関数 `fix` を **不動点コンビネータ** という
`Z` はよく知られた不動点コンビネータのひとつ

---

### まとめ？

* ループも再帰も使わずに再帰っぽいことがしたい
* -> 不動点コンビネータを使う必要がある
* たぶん今日は5分以内

---

![](explosion.jpg)

---

### まとまってない

* ループも再帰も使わずに再帰っぽいことがしたい
* -> ~~不動点コンビネータを使う必要がある~~
* 実は使わなくてもできる

---

```
(g => g(g))(f => n => n == 0 ? 1 : n * f(f)(n - 1))(5)
```

---

### 不動点コンビネータを使わない再帰的計算

```
(g => g(g))(f => n => n == 0 ? 1 : n * f(f)(n - 1))(5)
```

`g => g(g)` は自己適用コンビネータと呼ばれる
（不動点コンビネータではない）

不動点コンビネータを使わずに式をシンプルにできている

---

### 真のまとめ

* ループも再帰も使わずに再帰っぽいことがしたい
* 自己適用コンビネータを使うとできることが多い
    * こちらのほうがシンプルなことが多い
* 不動点コンビネータを使えばもちろんできる
    * 関数の body を変えなくて良いという利点がある

---

### ちなみに

* `g => g(g)` の型について語りだすと10や20分ではすまない
* （だからあえて今回はJavaScriptを使った）
