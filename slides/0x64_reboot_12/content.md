<!-- $theme: gaia -->

### 不動点コンビネータ？

##### @yubessy

#### 0x64物語 Reboot #12

#### "λ"

---

##### ※今日は珍しくJavaScript(ES6)でお送りします！

---

### Q1. 階乗を計算せよ

---

### A1.

```js
for (var p = 1, n = 1; n <= 5; n++) p *= n
p
// -> 120
```

---

### Q2. ループを使わずに階乗を計算せよ

---

### A2.

```js
var f = n => n == 0 ? 1 : n * f(n - 1)
f(5)
// -> 120
```

---

### Q3. ループと再帰を使わずに階乗を計算せよ

---

### A3.

```js
(g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y))))(f => n => n == 0 ? 1 : n * f(n - 1))(5)
// -> 120
```

※見やすく改行

```js
(g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y))))
(f => n => n == 0 ? 1 : n * f(n - 1))
(5)
```

---

### なぜこうなるのか

式を３つの部分に分けてみる

```js
Z = g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
g = f => n => n == 0 ? 1 : n * f(n - 1)
x = 5
```

`g` はA2の階乗の定義とよく似ている

```js
f = n => n == 0 ? 1 : n * f(n - 1)
```

ただし名前の付いた関数ではなく **ラムダ式** である

---

### なぜこうなるのか

ここでもし `Z` が `Z(g) = g(Z(g))` をみたせば・・・？

```js
  Z(g)(5)
= g(Z(g))(5)
= (f => n => n == 0 ? 1 : n * f(n - 1))(Z(g))(5)
= (n => n == 0 ? 1 : n * (Z(g))(n - 1))(5)
= 5 == 0 ? 1 : 5 * (Z(g))(5 - 1)
= 5 * (Z(g))(4)
= ...
= 5 * 4 * 3 * 2 * 1
```

※厳密には3行目以降の `Z(g)` は先に評価されている

---

### なぜこうなるのか

```js
Z = g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
```

は実際に `Z(g) = g(Z(g))` をみたす

```js
  Z(g)
= (g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y))))(g)
= (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
= (h => g(x => h(h)(x)))(h => g(y => h(h)(y))) // α-変換
= g(x => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))(x))
= g((h => g(y => h(h)(y)))(h => g(y => h(h)(y))) // η-変換
= g(Z(g))
```

---

### 無名再帰と不動点コンビネータ

```js
(g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y))))
(f => n => n == 0 ? 1 : n * f(n - 1))
(5)
```

**無名再帰** = 無名関数のみによる再帰的な計算

**不動点コンビネータ** = `fix(g) = g(fix(g))` なる `fix`

今回の `Z` は正格評価で使える不動点コンビネータ

※遅延評価ではよりシンプルな形式が存在

---

### まとめ？

* ループも再帰も使わずに再帰的な計算がしたい
* -> 不動点コンビネータを使う必要がある

---

### というのは間違い

# ![](pop.jpg)

---

### まとまってない

* ループも再帰も使わずに再帰的な計算がしたい
* ~~-> 不動点コンビネータを使う必要がある~~
* **実は使わなくてもできる**

---

### 不動点コンビネータを使わない例

```js
(g => g(g))(f => n => n == 0 ? 1 : n * f(f)(n - 1))(5)
```

`g => g(g)` は**自己適用コンビネータ**と呼ばれる

これは不動点コンビネータではない

でもこっちのほうがシンプル

---

### 真のまとめ

* 不動点コンビネータ以外でも無名再帰はできる
* 自己適用コンビネータを使うとシンプル
  * ただし関数の body が若干変わる
* 不動点コンビネータを使ってももちろんできる
  * こちらは関数の body を変えなくてよい

##### 参考

http://matt.might.net/articles/js-church/

---

### 裏話

本当は不動点コンビネータや自己適用コンビネータの
**型** について勉強したかった（というかしてきた）

-> **1時間や2時間では済まない**ことが判明
-> 自主規制によりHaskellやOCamlは諦めてES6に

興味ある人はこのへんをどうぞ

https://en.wikipedia.org/wiki/Fixed-point_combinator#Type_for_the_Y_combinator

http://okmij.org/ftp/Computation/fixed-point-combinators.html

---

### toolbox

```ocaml
fun f -> f f

fun g -> (fun h y -> g (h h) y) (fun h y -> g (h h) y)

fun f n -> if n == 0 then 1 else n * f(n -1)
```
