<!-- $theme: gaia -->

### 不動点コンビネータ

##### @yubessy

#### 0x64物語 Reboot #12

#### "λ"

---

##### ※今日は珍しくJavaScript(ES6)でお送りします！

---

### Q1. 階乗を計算せよ

---

### A1

```
for (var p = 1, n = 1; n <= 5; n++) p *= n;
p;
```

---

### Q2. ループを使わずに階乗を計算せよ

```
var f = n => n == 0 ? 1 : n * f(n - 1);
f(5);
```

---

### A2

---

### Q3. ループと再帰を使わずに階乗を計算せよ

---

### A3

```
(g => (x => g(y => x(x)(y)))(x => g(y => x(x)(y))))(f => n => n == 0 ? 1 : n * f(n - 1))(5)
```

---

### なぜこうなるのか

式を３つの部分に分けてみる

```
Z … g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
g … f => n => n == 0 ? 1 : n * f(n - 1)
x … 5
```

`g` は階乗の定義とよく似ている

```
var f = n => n == 0 ? 1 : n * f(n - 1);
```

違いは名前の付いた関数ではなく **ラムダ式** であること

---

### なぜこうなるのか

ここでもし `Z` が以下をみたすラムダ式なら？

```
Z(g) = g(Z(g))
```

```
  Z(f => n => n == 0 ? 1 : n * f(n - 1))(5)
= (f => n => n == 0 ? 1 : n * f(n - 1))(Z(f => n => n == 0 ? 1 : n * f(n - 1)))(5)
= (n => n == 0 ? 1 : n * (Z(f => n => n == 0 ? 1 : n * f(n - 1)))(n - 1))(5)
= 5 == 0 ? 1 : 5 * (Z(f => n => n == 0 ? 1 : n * f(n - 1)))(5 - 1))
= 5 * (Z(f => n => n == 0 ? 1 : n * f(n - 1)))(4))
= ...
= 5 * 4 * 3 * 2 * 1
```

※２行目以降の `Z(...)` は厳密には評価済み

---

### なぜこうなるのか

```
Z … g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
```

は実際に `Z(g) = g(Z(g))` をみたす

```
  Z(g)
= (g => (h => g(y => h(h)(y)))(h => g(y => h(h)(y))))(g)
= (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
= (h => g(x => h(h)(x)))(h => g(y => h(h)(y)))
= g(x => (h => g(y => h(h)(y)))(h => g(y => h(h)(y)))(x))
= g((h => g(y => h(h)(y)))(h => g(y => h(h)(y)))
= g(Z(g))
```

---

### なぜこうなるのか

よって以下の式は5の階乗を計算する

```
(g => (x => g(y => x(x)(y)))(x => g(y => x(x)(y))))(f => n => n == 0 ? 1 : n * f(n - 1))(5)
```

このように無名関数のみで再帰に相当する計算を行うことを **無名再帰** という
また `fix(g) = g(fix(g))` をみたす高階関数 `fix` を **不動点コンビネータ** という
`Z` はよく知られた不動点コンビネータのひとつ

---

### ここまで

---

# へ～
